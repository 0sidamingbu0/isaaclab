# 模型测试结果分析

## 测试日期
2025-11-03

## 测试模型
`logs/rsl_rl/oceanbdx_locomotion/2025-10-31_10-39-00/exported/policy.pt`

## 测试条件
- **姿态**: 默认站立姿态 (height=0.4m, upright)
- **命令**: 静止命令 [0, 0, 0] (无前进/转向)
- **观测**: 74维,完全符合训练格式
  - `ang_vel_body`: [0, 0, 0]
  - `gravity_vec`: [0, 0, -1] (归一化,正确!)
  - `dof_pos_rel`: 全0 (在default_dof_pos)
  - `dof_vel_scaled`: 全0 (静止)
  - `joint_torques`: 全0 (无负载)
  - `commands`: [0, 0, 0] (静止)
  - `last_actions`: 全0 (初始状态)
  - `adaptive_phase`: [0, 1, 0, 1, 0, 1, 0.6667, 0, 0.37] (正确)

---

## ✅ 测试结果: **模型输出正常!**

### 动作输出统计
```
范围: [-0.9644, 0.7120]
平均值: -0.0254
标准差: 0.3943
极端值 (|action| > 1.5): 0 / 14
```

### 详细动作值 (训练顺序: L1-L5, R1-R5, N1-N4)
```
左腿:
  L1: -0.0827
  L2:  0.3333
  L3: -0.2954
  L4:  0.7120
  L5: -0.4442

右腿:
  R1:  0.1568
  R2: -0.2259
  R3: -0.1768
  R4:  0.2263
  R5:  0.0045

颈部:
  N1: -0.9644  ⚠️ 最大值
  N2:  0.0712
  N3:  0.4182
  N4: -0.0887
```

### 目标关节位置 (default + action * 0.5)
```
关节 | Default  | Action   | Target   | Deviation
---------------------------------------------------------
L1   |    0.130 |   -0.083 |    0.089 |   -0.041
L2   |    0.070 |    0.333 |    0.237 |    0.167
L3   |    0.200 |   -0.295 |    0.052 |   -0.148
L4   |    0.052 |    0.712 |    0.408 |    0.356
L5   |   -0.050 |   -0.444 |   -0.272 |   -0.222
R1   |   -0.130 |    0.157 |   -0.052 |    0.078
R2   |   -0.070 |   -0.226 |   -0.183 |   -0.113
R3   |   -0.200 |   -0.177 |   -0.288 |   -0.088
R4   |   -0.052 |    0.226 |    0.061 |    0.113
R5   |    0.050 |    0.004 |    0.052 |    0.002
N1   |    0.000 |   -0.964 |   -0.482 |   -0.482
N2   |    0.000 |    0.071 |    0.036 |    0.036
N3   |    0.000 |    0.418 |    0.209 |    0.209
N4   |    0.000 |   -0.089 |   -0.044 |   -0.044

最大偏离: 0.482 rad (N1颈部关节)
```

---

## 🔍 结果分析

### ✅ 正常表现
1. **动作范围合理**: [-0.96, 0.71],没有极端值 (±2)
2. **平均值接近0**: -0.0254,符合静止命令预期
3. **标准差适中**: 0.3943,表明模型输出较为稳定
4. **目标位置偏离**: 最大0.482 rad (N1),这对于静止命令是可接受的微调

### ⚠️ 注意事项
- **N1颈部关节**: action=-0.9644 是最大值,但仍在合理范围内
- **L4腿部关节**: action=0.7120 是第二大值
- 这些值在clip_actions=[-2, 2]范围内,不算极端

### 📊 与部署日志对比

#### **部署 Step 0 输出** (之前的日志)
```
Actions: [ 2.0000,  1.8919,  1.9865, -2.0000, -2.0000,
          -2.0000, -2.0000, -1.5865,  2.0000, -1.7406,
          -0.4001, -0.1459,  1.8593,  2.0000]
```
- **极端值**: 10/14 个动作是 ±2 附近
- **平均值**: 约0 (但大量极端值)
- **标准差**: 约1.8 (远大于训练模型)

#### **训练模型输出** (本次测试)
```
Actions: [-0.0827,  0.3333, -0.2954,  0.7120, -0.4442,
           0.1568, -0.2259, -0.1768,  0.2263,  0.0045,
          -0.9644,  0.0712,  0.4182, -0.0887]
```
- **极端值**: 0/14
- **平均值**: -0.0254
- **标准差**: 0.3943

---

## 🎯 **结论: 问题在部署代码,不在模型!**

### 证据
1. **相同输入,不同输出**:
   - 训练测试: 74维观测 (default姿态+静止命令) → 合理动作
   - 部署 Step 0: 74维观测 (default姿态+静止命令) → 极端动作
   
2. **模型在Isaac Lab play模式正常** (用户已确认)

3. **模型在Python直接测试正常** (本次测试)

4. **部署代码在Step 0输出异常**

### 问题定位
部署代码的观测计算与训练时有**微妙差异**,导致模型接收到"错误"的观测,从而输出极端动作。

---

## 🔧 下一步调试方向

### 1. **比较部署 Step 0 的实际观测值**
部署AI需要打印 Step 0 时传入模型的**原始74维观测向量**,逐项对比:

```cpp
// 部署代码需要添加详细日志
std::vector<float> observation = constructObservation();
std::cout << "Step " << step_count << " Observation (74-dim):\n";
for (int i = 0; i < 74; i++) {
    std::cout << "  [" << i << "] " << observation[i] << "\n";
}
```

然后与训练测试的观测对比,找出差异项。

### 2. **重点检查以下观测项计算**

#### (1) `gravity_vec` (索引 3-5)
- **训练**: `[0, 0, -1]` (归一化!)
- **部署 Step 0**: 应该是 `[0, 0, -1]` (用户日志已确认正确)
- **部署 Step 100+**: `[-9.186, 0.449, 3.412]` (未归一化,**错误!**)

**修复**: 确保 `gravity_vec` 始终归一化:
```cpp
Eigen::Vector3d gravity_body = quat.inverse() * Eigen::Vector3d(0, 0, -9.81);
gravity_body.normalize();  // 必须归一化!
```

#### (2) `dof_pos_rel` (索引 6-19)
- **训练**: `current_pos - default_dof_pos`
- **部署**: 检查 `default_dof_pos` 是否与训练一致

训练的 `default_dof_pos` (Isaac Lab alphabet顺序: L1-L5, R1-R5, N1-N4):
```python
[0.13, 0.07, 0.2, 0.052, -0.05,    # L1-L5
 -0.13, -0.07, -0.2, -0.052, 0.05, # R1-R5
 0, 0, 0, 0]                        # N1-N4
```

部署的 `default_joint_positions` (URDF顺序: R1-R5, L1-L5, N1-N4):
```yaml
[-0.13, -0.07, -0.2, -0.052, 0.05,  # R1-R5
  0.13,  0.07,  0.2,  0.052, -0.05, # L1-L5
  0,     0,     0,     0]            # N1-N4
```

**关键**: 计算 `dof_pos_rel` 时,要先用 `joint_mapping` 将当前位置从URDF顺序转换到训练顺序,再减去default:
```cpp
// 错误做法 (可能的bug)
for (int i = 0; i < 14; i++) {
    dof_pos_rel[i] = current_pos[i] - default_pos[i];  // 顺序不匹配!
}

// 正确做法
for (int i = 0; i < 14; i++) {
    int train_idx = i;  // 训练顺序索引
    int urdf_idx = joint_mapping[i];  // 对应的URDF索引
    dof_pos_rel[train_idx] = current_pos[urdf_idx] - default_pos_train_order[train_idx];
}
```

#### (3) `dof_vel_scaled` (索引 20-33)
- **训练**: `current_vel * 0.05` (velocity_scale=0.05)
- 检查部署是否也乘了 0.05

#### (4) `joint_torques` (索引 34-47)
- **训练**: 原始力矩值,无缩放
- 检查部署的力矩值是否正确

#### (5) `adaptive_phase` (索引 62-70)
训练侧已验证计算正确,但部署侧需要再次确认:
```python
# 训练计算 (oceanbdx_env.py)
phase_sin = torch.sin(2 * torch.pi * gait_phase)
phase_cos = torch.cos(2 * torch.pi * gait_phase)
double_phase_sin = torch.sin(4 * torch.pi * gait_phase)
double_phase_cos = torch.cos(4 * torch.pi * gait_phase)
normalized_gait_freq = (gait_freq - 2.0) / (4.0 - 2.0)
gait_offset_1 = torch.clamp(gait_offset[:, 0], 0.0, 0.5) / 0.5
gait_offset_2 = torch.clamp(gait_offset[:, 1], 0.0, 0.5) / 0.5
```

### 3. **使用测试用例验证**

生成标准测试用例:
```bash
cd /home/ocean/oceanbdx/oceanbdx
python generate_standard_test_cases.py
```

然后在部署代码中加载 `test_cases.json`,逐项对比观测计算。

---

## 📋 给部署 AI 的任务清单

### 🔴 紧急任务

1. **修复 adaptive_phase 最后3维** ⭐ **新发现!**
   - 当前: `[0.0, 0.0, 0.0]` - **完全错误!**
   - 修复: `[0.6667, 0.0, 0.37]` - 训练环境验证值
   - 详见: `ADAPTIVE_PHASE_FIX.md`
   ```cpp
   obs[71] = 0.6667f;  // phase_rate_norm
   obs[72] = 0.0f;     // stride_norm (静止)
   obs[73] = 0.37f;    // clearance_norm
   ```

2. **修复 gravity_vec 归一化**
   - 当前: Step 100+ 的 `gravity_vec` 未归一化 (magnitude=9.81)
   - 修复: 确保始终归一化 (magnitude=1)
   ```cpp
   gravity_body.normalize();
   ```

3. **打印 Step 0 完整观测**
   - 打印传入模型的 74 维观测向量
   - 与训练测试的观测逐项对比
   - 找出差异项

### 🟡 高优先级任务

3. **验证 dof_pos_rel 计算**
   - 确认 `joint_mapping` 正确应用
   - 确认 `default_dof_pos` 与训练一致
   - 检查顺序转换逻辑

4. **验证 dof_vel_scaled 计算**
   - 确认乘了 velocity_scale=0.05

5. **验证 adaptive_phase 计算**
   - 对比训练侧公式
   - 检查 gait_phase, gait_freq, gait_offset 的值

### 🟢 中优先级任务

6. **使用测试用例验证**
   - 加载 `test_cases.json`
   - 逐项对比观测计算结果

7. **检查关节顺序一致性**
   - 确认观测、动作、关节映射的顺序都正确

---

## 📊 预期结果

修复后,部署 Step 0 的动作输出应该与训练测试接近:
```
期望: [-0.08, 0.33, -0.30, 0.71, -0.44, 0.16, -0.23, -0.18, 0.23, 0.00, -0.96, 0.07, 0.42, -0.09]
实际: [ 2.00, 1.89,  1.99, -2.00, -2.00, -2.00, -2.00, -1.59,  2.00, -1.74, -0.40, -0.15,  1.86,  2.00]
差异: 巨大! 需要找出观测计算的bug
```

---

## 💡 额外建议

1. **逐步验证**:
   - 先确保 Step 0 观测完全正确
   - 再测试 Step 1-10
   - 最后测试完整运行

2. **对比工具**:
   - 可以写一个 Python 脚本读取部署日志
   - 自动对比训练测试的观测/动作
   - 高亮差异项

3. **单元测试**:
   - 为每个观测项写单元测试
   - 确保计算逻辑与训练一致

---

## 🎯 最终目标

修复后,部署代码应该能够:
1. ✅ Step 0 输出合理动作 (接近训练测试)
2. ✅ 机器人站立不倒
3. ✅ 响应 forward/turn 命令
4. ✅ 与 Isaac Lab play 模式表现一致

**祝调试顺利!** 🚀
